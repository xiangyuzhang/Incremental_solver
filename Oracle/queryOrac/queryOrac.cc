#include <map>
#include <string>
#include <vector>
#include <sstream>
#include <fstream>
#include <iostream>
#include <regex>

#include "queryOrac/queryOrac.h"
#include "queryOrac/tools.h"
#include "queryOrac/dict.h"
#include "simp/SimpSolver.h"
#include "utils/System.h"
#include "utils/ParseUtils.h"
#include "utils/Options.h"
#include "core/Dimacs.h"

using namespace Minisat;
using namespace std;

Oracle::Oracle(const char * ora, const char * PI, const char * PO)
{
    cout << "a Oracle is created" << endl;
    PI_path = PI;
    PO_path = PO;
    Orac_Path = ora;
}


void Oracle::genOracCNF()
{
    ifstream infile;
    vector<string> Vlines;
    load_gateTypeDict(gateTypeDict);

    cout << "reading data from " << Orac_Path << endl;

    Vlines = ReadByColon(Orac_Path);


    cnFile.push_back("c oracle circuit:\n");
    for(vector<string>::iterator iter = Vlines.begin(); iter != Vlines.end(); ++iter)
    {
        string line = *iter;
        strip_all(line, "\n");


        if((line.find("input") != string::npos) && (line.find("//") == string::npos))
        {
            cout << "Processing input (PI or CB)" << endl;
            // use regex to find input netname
            strip_all(line, "input");
            strip_all(line, " ");
            SplitString(line, PIs, ",");
            for(vector<string>::iterator pi = PIs.begin(); pi != PIs.end(); ++pi)
            {
                strip_all(*pi, "\\");
                strip_all(*pi, "[");
                strip_all(*pi, "]");
                varIndexDict.insert(std::pair<string, int>(*pi, varIndex));
                indexVarDict.insert(std::pair<int, string>(varIndex, *pi));
                pisIndex.push_back(varIndex);
                varIndex++;

            }
        }

        else if((line.find("output") != string::npos) && (line.find("//") == string::npos))
        {
            cout << "Processing output " << endl;
            strip_all(line, "output");
            strip_all(line, " ");
            SplitString(line, POs, ",");
            for(vector<string>::iterator po = POs.begin(); po != POs.end(); ++po)
            {
                strip_all(*po, "\\");
                strip_all(*po, "[");
                strip_all(*po, "]");
//              cout << *po << endl;
                posIndex.push_back(varIndex);
                varIndexDict.insert(std::pair<string, int>(*po, varIndex));
                indexVarDict.insert(std::pair<int, string>(varIndex, *po));
                varIndex++;
            }
        }

        else if((line.find("wire") != string::npos) && (line.find("//") == string::npos))
        {
            cout << "Processing wire" << endl;
            strip_all(line, "wire");
            strip_all(line, " ");
            SplitString(line, wires, ",");
            for(vector<string>::iterator w = wires.begin(); w != wires.end(); ++w)
            {
                strip_all(*w, "\\");
                strip_all(*w, "[");
                strip_all(*w, "]");
                strip_all(*w, "\\t");
//              cout << *w << endl;
                varIndexDict.insert(std::pair<string, int>(*w, varIndex));
                indexVarDict.insert(std::pair<int, string>(varIndex, *w));
                varIndex++;
            }
        }

        else if( (line != "") && (line.front() != '/') && (line.find("module") == string:: npos))
        {
            string gate;
            vector<string> gate_cnf;
//            cout << line << endl;
            if((line.find(".") != string::npos) && (line.find("(") != string::npos))
            {

                gate = find_gatetype(line);
                strip_all(gate," ");
                strip_all(gate,"\n");
                strip_all(gate,"\t");
            }
            else
            {
                cout << "verilog format is not acceptable!!!" << endl;
                exit(-1);
            }
            vector<string> netname;
            vector<int> lineIn;
            int lineOut;

            netname = find_netname(line);
            lineOut = varIndexDict[netname.back()];
            for(vector<string>::iterator iter = netname.begin(); iter != netname.end() - 1; ++iter)
            {
//                cout << varIndexDict[*iter] << endl;
                lineIn.push_back(varIndexDict[*iter]);
            }

            int caseNo = gateTypeDict[gate];
            gate_cnf = transGATE(caseNo, lineIn, lineOut);
            for(vector<string>::iterator iter = gate_cnf.begin(); iter != gate_cnf.end(); ++iter)
            {
//                cout << *iter << endl;
                cnFile.push_back(*iter);
            }
            gateCnt++;
        }
        varNum = varIndex;
    }
    clauseNum = cnFile.size();
    string cmmtline1 = "c This file is generated by oracV2cnf\n";
    string cmmtline2 = "c Generated on " + get_localtime();
    clauseNum += pisIndex.size();
    string firstLine = "p cnf " + tostring(varNum - 1) + " " + tostring(clauseNum - 1)  + " \n";
    cnFile.insert(cnFile.begin(), firstLine);
    cnFile.insert(cnFile.begin(), cmmtline2);
    cnFile.insert(cnFile.begin(), cmmtline1);


    print_vector(cnFile, Orac_cnf);
}

void Oracle::process()
{
    genOracCNF();
    parse_PI();
    assign_PI();
    solve();
    print_map(PO_temp);
    export_PO();

}
void Oracle::export_PO()
{
	ofstream outfile;
	outfile.open(PO_path, std::ios::out);
	for(map<int,string>::iterator index = PO_temp.begin(); index != PO_temp.end(); ++index)
	{
		outfile << indexVarDict[index->first] << "\t";
	}
	outfile << endl;
	for(map<int, string>::iterator index = PO_temp.begin(); index != PO_temp.end(); ++index)
	{
		outfile << index->second << "\t";
	}
	outfile << endl;
}
void Oracle::parse_PI() {
    cout << "reading from " << PI_path << endl;
    ifstream infile;
    infile.open(PI_path, std::ios::in);
    string first_line;
    string second_line;

    getline(infile, first_line);
    getline(infile, second_line);

    vector<string> name_temp;
    vector<string> value_temp;
    SplitString(first_line, name_temp, "\t");
    SplitString(second_line, value_temp, "\t");

    vector<string>::iterator value = value_temp.begin();
    for(vector<string>::iterator name = name_temp.begin(); name != name_temp.end(); ++name)
    {
    	PI_temp.insert(pair<int, string>(varIndexDict[*name], *value));
    	value++;
    }
}

void Oracle::assign_PI(){
	vector<int>::iterator position = pisIndex.begin();
	for(map<int, string>::iterator index = PI_temp.begin(); index != PI_temp.end(); ++index)
	{
		if(index->second == "1") PI_assignment_cnf.push_back(tostring(*position) + " 0\n");
		else if(index->second == "0") PI_assignment_cnf.push_back("-" + tostring(*position) + " 0\n");
		position++;
	}
	PI_assignment_cnf.insert(PI_assignment_cnf.begin(), "c this is assign_PI\n");
	cnFile += PI_assignment_cnf;
	print_vector(cnFile, Orac_cnf);
}


void Oracle::solve(){
	cout << "start solving" << endl;
	SimpSolver S;
	gzFile in = gzopen(Orac_cnf, "rb");
	parse_DIMACS(in, S);
	for(vector<int>::iterator index = posIndex.begin(); index != posIndex.end(); ++index)
	{
		S.setFrozen(*index - 1, true);
	}
	S.eliminate(true);
	if(!S.okay()) 
	{
		cout << "UNSAT";
		exit(20);
	}

	vec<Lit> dummy;
	lbool ret = S.solveLimited(dummy);

	if(ret == l_True)
	{
		cout << "SAT" << endl;
		for(vector<int>::iterator index = posIndex.begin(); index != posIndex.end(); ++index)
		{
			string temp_value;
			if(S.model[*index - 1] == l_True)
			{
				temp_value = "1";
			}
			else if(S.model[*index - 1] == l_False) 
			{
				temp_value = "0";
			}
			PO_temp.insert(std::pair<int, string>(*index, temp_value));
		}
	}
	else if(ret == l_False) cout << "UNSAT" << endl;
	else cout << "INDET" << endl;
}
